{"version":3,"sources":["../src/index.ts","../src/createPrompt.ts","../src/constants.ts","../src/type-guards.ts","../src/utils/asString.ts","../src/utils/parseMarkdown.ts","../src/utils/codeBlock.ts","../src/utils/processPrompt.ts","../src/errors.ts","../src/utils/logger.ts","../src/scrape/getPage.ts","../src/scrape/htmlToMd.ts","../src/utils/prettyFile.ts","../src/utils/link.ts","../src/utils/toClipboard.ts","../src/utils/updatePromptFile.ts","../src/help.ts","../src/envReport.ts","../src/report.ts","../src/utils/configSwitches.ts"],"sourcesContent":["#!/usr/bin/env bun run \n\nimport { argv, exit } from \"node:process\";\nimport { createPrompt } from \"./createPrompt\";\nimport { help } from \"./help\";\nimport { envReport } from \"./envReport\";\nimport { configSwitches } from \"./utils/configSwitches\";\n\nconst { args, switches } = configSwitches(argv,{\n    output: [\"o\", \"string\"],\n    replace: \"boolean\",\n    refresh: \"boolean\",\n    aider: \"boolean\",\n    env: \"boolean\",\n    \"dry-run\": \"boolean\",\n    \"verbose\": [\"v\", \"boolean\"],\n    help: [\"h\", \"boolean\"],\n    yes: [\"y\", \"boolean\"]\n});\n\nexport type Switches = typeof switches;\n\n\n// Main CLI logic\nasync function main() {\n\n\n    // const args = argv.slice(2).filter(i => !i.startsWith(`-`));\n    // const switches = argv.slice(2).filter(i => i.startsWith(`-`));\n   \n\n    if (switches.env) {\n        await envReport();\n        exit(0);\n    }\n\n    if (args.length === 0 || switches.help) {\n        help();\n        exit(0);\n    }\n\n    return await createPrompt(args, switches);\n}\n\nawait main();\n","import FastGlob from \"fast-glob\";\nimport {  PROMPTS_GLOB } from \"./constants\";\nimport { ask, ask as q } from \"@yankeeinlondon/ask\"\nimport chalk from \"chalk\";\nimport { cwd, exit } from \"node:process\";\nimport { resolve } from \"pathe\";\nimport { Prompt } from \"./types\";\nimport { Switches } from \".\";\nimport { \n    fail, \n    info, \n    infoIndent, \n    log, \n    prettyFile, \n    processPrompt, \n    success, \n    toClipboard, \n    updatePromptFile\n} from \"./utils\";\nimport { writeFileSync } from \"node:fs\";\nimport { relative } from \"node:path\";\n\n\n/**\n * replaces all requests for `file` or `web` resources\n */\nasync function processPrompts(\n    files: string[],\n    s: Switches\n): Promise<Prompt[]> {\n    \n    const wait = files.map(i => processPrompt(i, s));\n    const results = await Promise.all(wait) as Prompt[];\n    \n    return results;\n}\n\n\n/**\n * Combine one or more **prompt** files and replace all `file` and `web` references\n * with the appropriate content.\n * \n * Output is always placed on the clipboard but if `-o <filename>` is provided then \n * it will also write to a file.\n */\nexport async function createPrompt(args: string[], s: Switches) {\n    const promptFiles: string[] = [];\n    const promptContent = [];\n    log();\n    \n    const candidates = await FastGlob(PROMPTS_GLOB);\n    if(candidates.length === 0) {\n        fail(`no prompts found; run ${chalk.blue.bold(\"prompt --env\")} to better understand the current configuration of the CLI`)\n        exit(1);\n    } else {\n        info(`${chalk.bold.yellow(candidates.length)} candidate ${chalk.bold(\"prompt\")} files found in the path`)\n    }\n    let freeFormQuestion = \"\";\n\n    let requiresConfirmation = false;\n\n    for (const [idx, arg] of args.entries()) {\n        /** matched prompt files */\n        const found = candidates.filter(c => c.includes(arg));\n\n        if(found.length > 0) {\n            const exactMatches = found.filter(i => arg === i);\n            if (exactMatches.length === 1) {\n                success(`Matched the prompt file \"${arg}\" -> ${resolve(cwd(), exactMatches[0])}`);\n            } else if (exactMatches.length > 1) {\n                confirm(`We found more than one prompt file which matches \"${arg}\"\\n`);\n                promptFiles.push(\n                    await q.select(\"select\", \"Choose which file to use\", exactMatches)()\n                );\n            } else if (found.length === 1) {\n                success(`Matched the prompt file \"${arg}\" -> ${resolve(cwd(), found[0])}`);\n                promptFiles.push(found[0]);\n            } else if (found.length > 1) {\n                requiresConfirmation = true;\n                confirm(`We found more than one prompt file which matches \"${arg}\"\\n`);\n                promptFiles.push(\n                    await q.select(\"select\", \"Choose which file to use\", exactMatches)()\n                );\n            }\n        } else {\n            // no matches found with available prompts\n\n            const remainingHaveExt = args.slice(idx).some(\n                i => i.endsWith(\".md\") || i.endsWith(\".txt\")\n            );\n\n            if(remainingHaveExt) {\n                requiresConfirmation = true;\n                fail(`the text \"${chalk.bold(arg)}\" ${chalk.dim.italic(`-- as well as the variant \"${chalk.bold(`${arg}.md`)}\" --`)} found no match for prompt files`);\n                console.log();\n                const action = q.select(\n                    \"action\", \n                    `What action should we take?`,\n                    {\n                        \"skip this text and continue with the rest\": \"skip\",\n                        \"quit for now to restate the CLI command\": \"quit\"\n                    }\n                );\n                const answer = await action();\n                if (answer === \"quit\") {\n                    exit(1);\n                }\n            } else {\n                \n                if (\n                    arg.length > 15 && arg.includes(\" \")\n                ) {\n                    requiresConfirmation = true;\n                    freeFormQuestion = args.slice(idx).join(\" \");\n                    success(\"set freeform text to be added to end of prompt\")\n                    break;\n                } else {\n                    requiresConfirmation = true;\n                    fail(`the parameter ${chalk.bold.red(arg)} was not matched to a template and will be dropped.`)\n\n                }\n            }\n        }\n    } // end prompt files\n\n\n    if(requiresConfirmation) {\n        log()\n        const promptMsg = promptFiles.length > 0 \n            ? `The prompt files, ${chalk.italic(\"in order\")}, are:\\n${promptFiles.map(i => `  - ${prettyFile(i)}`).join(\"\\n\")}`\n            : `${chalk.bold.italic(\"No\")} prompt files where found in the params!`\n        const freeform = freeFormQuestion === \"\"\n            ? \"\"\n            : promptFiles.length > 0\n                ? `The following ${chalk.bold(\"freeform question\")} will be appended to the end of the prompt chain:\\n\\n    ${chalk.italic(freeFormQuestion)}\\n`\n                : `The following ${chalk.bold(\"freeform question\")} will be the full extent of the prompt as no prompt\\n  references were found:\\n\\n    ${chalk.italic(freeFormQuestion)}\\n`;\n\n        info(promptMsg);\n        if(freeform) {\n            info(freeform);\n        }\n\n        if(\n            await q.confirm(\"confirm\", `Continue?`)()\n        ) {\n            // no-op\n        } else {\n            exit(1);\n        }\n    } \n\n    let prompts: Prompt[] = [];\n\n    if(promptFiles.length > 0) {\n        info(\n            `processing prompts [${chalk.bold.yellow(promptFiles.length)}] for inline references`\n        )\n        /**\n         * the `code`, `doc` and `web` resource requests embedded in the \n         * prompt file(s)\n         */\n        prompts = await processPrompts(promptFiles, s);    \n    }\n    const prompt = prompts.map(i => i.content).join(\"\\n\") + `\\n${freeFormQuestion}\\n`\n\n    const copied = await toClipboard(prompts[0].content);\n    if(copied) {\n        log();\n        success(`the prompt has been copied to the clipboard!`);\n    } else {\n        fail(`failed to copy prompt to the clipboard: ${(copied as Error).message}`)\n    }\n\n    if(s.output) {\n        writeFileSync(prompt, s.output, \"utf-8\");\n        success(`the prompt was saved to ${chalk.blue.bold(s.output)}`)\n    }\n\n    if(s.replace) {\n        for (const p of prompts) {\n            if (p.isCached && !s.refresh) {\n                info(`the \"${prettyFile(relative(cwd(), p.promptFile))}\" prompt file was ${chalk.italic(\"already\")} in a cached state.`)\n                infoIndent(`this file will be left unchanged as it was ${chalk.italic(\"not\")} re-evaluated for this prompt`)\n                infoIndent(`if you want to have the files and web references ${chalk.italic(\"re-evaluated\")} add the ${chalk.blue(`--refresh`)} flag to your command`)\n            } \n            else {\n                if(\n                    s.yes || \n                    ask.confirm(\n                        `confirm`, \n                        `Save the \"${prettyFile(relative(cwd(), p.promptFile))}\" with the ${chalk.italic(\"interpolated\")} results?`\n                    )\n                ) {\n                    await updatePromptFile(p);\n                    success(`prompt file ${chalk.bold.blue(relative(cwd(), p.promptFile))} saved backed to source`)\n                }\n            }\n        }\n    }\n}\n","import findRoot from \"find-root\";\nimport \"dotenv/config\"\nimport { cwd } from \"node:process\";\nimport { join } from \"pathe\";\nimport { existsSync, readFileSync } from \"node:fs\";\nimport { createKindError } from \"@yankeeinlondon/kind-error\";\nimport chalk from \"chalk\";\nimport { isConfigFile } from \"./type-guards\";\nimport { ConfigFile } from \"./types\";\nimport { fail, success } from \"./utils\";\nimport { isTruthy } from \"inferred-types/runtime\";\n\n\nexport const IGNORE_INVALID_CERT: boolean = isTruthy(process.env.IGNORE_INVALID_CERT)\n    ? true\n    : false;\n\nexport const EXT_TO_LANG = {\n    \"cpp\": \"cpp\",\n    \"c\": \"c\",\n    \"ts\": \"ts\",\n    \"js\": \"js\",\n    \"py\": \"py\",\n    \"sh\": \"sh\",\n    \"bash\": \"bash\",\n    \"php\": \"php\",\n    \"rs\": \"rust\",\n    \"json\": \"json\",\n    \"txt\": \"txt\",\n    \"toml\": \"toml\",\n    \"yaml\": \"yaml\",\n    \"yml\": \"yaml\",\n    \"md\": \"md\",\n    \"lua\": \"lua\",\n    \"\": \"text\",\n} as const\n\nexport const ROOT = findRoot(cwd()) || cwd();\n\nexport const CONFIG_FILE = join(ROOT, \"/.prompt.json\");\n\nconst InvalidConfig = createKindError(\n    \"InvalidConfig\"\n)\nlet _CONFIG: ConfigFile | undefined;\n\nif (existsSync(CONFIG_FILE)) {\n    try {\n        const data = readFileSync(CONFIG_FILE, \"utf-8\");\n        const parsed = JSON.parse(data);\n        if(isConfigFile(parsed)) {\n            success(`using the config file at ${chalk.blue(CONFIG_FILE)}`)\n            _CONFIG = parsed;\n        } else {\n            _CONFIG = undefined;\n            fail(`a config file was found at ${chalk.blue(CONFIG_FILE)} and was ${chalk.italic(\"parsed\")} but appears to be of the wrong format.`)\n        }\n    } catch (err) {\n        _CONFIG = undefined;\n        fail(`a config file was found at ${chalk.blue(CONFIG_FILE)} but it could not be parsed into a configuration file!\\n`)\n    }\n\n}\n\n\nexport const CONFIG = _CONFIG;\n\n/**\n * The directories to look for **prompt** files in\n */\nexport const PROMPTS_DIR = [\n    ...(\n        CONFIG\n        ? CONFIG.promptDirs ? CONFIG.promptDirs : [`${ROOT}/prompts`]\n        : [`${ROOT}/prompts`]\n    ),\n    ...(\n        process.env.PROMPTS\n            ? process.env.PROMPTS.split(\":\")\n            : []\n    )\n] as const;\n\nexport const PROMPTS_GLOB = PROMPTS_DIR.map(i => join(i, `/**/*.(md|txt)`));\n\nexport const CODE_PATHS = [\n    ...(\n        CONFIG && CONFIG.codePath\n            ? CONFIG.codePath\n            : [\n                `${ROOT}/src`,\n                `${ROOT}/test`,\n                `${ROOT}/tests`,\n            ]\n    ),\n    ...(\n        process.env.CODE\n            ? process.env.CODE.split(\":\")\n            : []\n    )\n]\n","import { isObject } from \"inferred-types\";\nimport { ConfigFile } from \"./types\";\n\nconst CONFIG_PROPS = [\n    \"promptDirs\",\n    \"codePath\",\n    \"docPath\"\n]\n\nexport function isConfigFile(val: unknown): val is ConfigFile {\n    return isObject(val) && Object.keys(val).every(i => CONFIG_PROPS.includes(i))\n}\n","import { isError, isKindError } from '@yankeeinlondon/kind-error';\nimport { isArray, isObject, isString } from 'inferred-types';\n\nexport function asString(val: unknown) {\n    return isError(val)\n        ? isKindError(val) ? String(val) : `${val.message}`\n        : isObject(val)\n        ? JSON.stringify(val)\n        : isArray(val)\n            ? JSON.stringify(val)\n            : isString(val)\n                ? val\n                : String(val);\n}\n","import { Frontmatter } from \"~/types\";\n\ntype ParsedMarkdown = [\n    fm: Frontmatter,\n    content: string\n]\n  \n/**\n * Splits out the frontmatter from the markdown prose\n */\nexport function parseMarkdown(fileContent: string): ParsedMarkdown {\n    if (fileContent.startsWith('---')) {\n      // Find the closing delimiter; start searching after the first '---'\n      const endOfFrontmatter = fileContent.indexOf('---', 3);\n      if (endOfFrontmatter !== -1) {\n        // Extract the frontmatter content (skip the initial and ending '---')\n        const frontMatterContent = fileContent.substring(3, endOfFrontmatter).trim();\n        // The rest of the file is the markdown content\n        const content = fileContent.substring(endOfFrontmatter + 3).trim();\n  \n        // Parse the frontmatter lines into a key/value object\n        const frontMatter: Record<string, string> = {};\n        const lines = frontMatterContent.split('\\n');\n        for (const line of lines) {\n          // Expect lines of the form \"key: value\"\n          const colonIndex = line.indexOf(':');\n          if (colonIndex !== -1) {\n            const key = line.substring(0, colonIndex).trim();\n            const value = line.substring(colonIndex + 1).trim();\n            frontMatter[key] = value;\n          }\n        }\n  \n        return [ frontMatter, content ];\n      }\n    }\n    \n    // If no frontmatter is found, return an empty object for frontmatter and the full file as content.\n    return [ {}, fileContent ];\n}\n\n","import { stripLeading } from \"inferred-types\";\nimport { basename, extname } from \"pathe\";\n\nexport function codeBlock(text: string, filename: string) {\n    return `\n##### ${basename(filename)}\n\n\\`\\`\\`${stripLeading(extname(filename), \".\")}\n${text.trim()}\n\\`\\`\\`\n\n`\n}\n","import { isUri, isUrl, retain, retainAfter, stripLeading, Uri } from \"inferred-types\";\nimport { Switches } from \"../index\";\nimport { FailedWebRef, Prompt } from \"~/types\";\nimport { readFileSync } from \"node:fs\";\nimport { createKindError } from \"@yankeeinlondon/kind-error\";\nimport { parseMarkdown } from \"./parseMarkdown\";\n\nimport chalk from \"chalk\";\nimport { CODE_PATHS } from \"~/constants\";\nimport FastGlob from \"fast-glob\";\nimport { readFile } from \"node:fs/promises\";\nimport { exit } from \"node:process\";\nimport { InputOutput } from \"~/errors\";\nimport { codeBlock } from \"./codeBlock\";\nimport { basename, join } from \"pathe\";\nimport { ask } from \"@yankeeinlondon/ask\";\nimport { fail, info, infoIndent, log } from \"./logger\";\nimport { getPage } from \"~/scrape\";\n\n\nconst InvalidPromptFile = createKindError(\n    \"InvalidPromptFile\"\n)\n\nexport async function processPrompt(\n    file: string,\n    s: Switches\n) {\n    let content = \"\";\n    let aiderContent = \"\";\n    let codeRefs: string[] = [];\n    let unmatchedCodeRefs: string[] = [];\n    let webRefs: Uri<\"http\" | \"https\">[] = [];\n    let invalidWebRefs: string[] = [];\n    let failedWebRefs: FailedWebRef[] = [];\n    let rawContent: string = \"\";\n    let errors: Error[] = [];\n\n    try {\n        rawContent = readFileSync(file, \"utf-8\");\n    } catch (err) {\n        throw InvalidPromptFile(`The file \"${file}\" couldn't be loaded as prompt file!`, {\n            underlying: err as Error | string\n        })\n    }\n\n    const [frontmatter, promptContent] = parseMarkdown(rawContent);\n\n    const isCached = frontmatter?.__cached\n        ? true\n        : false;\n\n    const lines = promptContent.split(\"\\n\");\n\n    if(s.verbose) {\n        info(`markdown parsed with frontmatter of [${lines.length} lines]`, frontmatter);\n    }\n\n    const characters = promptContent.length;\n\n    // Iterate over lines\n    for (const [idx, line] of lines.entries()) {\n        if(line.startsWith(\"::code \")) {\n            const refs = stripLeading(line, \"::code \")\n            .split(\",\").map(i => i.trim());\n            if(s.verbose) {\n                info(\n                    `found ${chalk.bold.yellow(refs.length)} code reference(s) on line ${idx} of ${file}`, \n                    refs\n                )\n            }\n\n            for (const ref of refs) {\n                const glob = CODE_PATHS.map(i => join(i, `**/*${ref}*`));\n                const candidates = await FastGlob(glob);\n                if(candidates.length === 1) {\n                    try {\n                        const text = await readFile(candidates[0], \"utf-8\");\n                        codeRefs.push(candidates[0]);\n                        content += codeBlock(text, candidates[0]);\n                        aiderContent += `/add ${candidates[0]}\\n`;\n                    } catch (err) {\n                        errors.push(InputOutput(`Unable to load content of code file: ${candidates[0]}`))\n                    }\n                } else if (candidates.length > 1) {\n                    log();\n                    log(`In the prompt file ${chalk.blue.bold(file)} we found a code reference to \"${ref}\"`);\n                    log();\n                    log(`This reference matches ${chalk.italic(\"more\")} than one code file in your code path.`)\n\n                    const choose = await ask.select(\"choose\", \"Which code should we include:\", [...candidates, \"QUIT\"])()\n\n                    if(choose === \"QUIT\") {\n                        log(\"Bye\")\n                        log();\n                        exit(0);\n                    }\n                    const text = await readFile(choose, \"utf-8\");\n                    content += codeBlock(text, choose);\n                    aiderContent += `/add ${choose}\\n`\n                }\n            }\n\n\n        } else if(line.startsWith(\"::web \")) {\n            const urlsCandidates = line.replace(\"::web \", \"\").split(\",\").map(i => i.trim()).filter(i => i);\n            const validUrls = urlsCandidates.filter(i => isUrl(i, \"http\",\"https\"));\n            if (validUrls.length !== urlsCandidates.length) {\n                const invalid = urlsCandidates.filter(i => !isUrl(i, \"http\",\"https\"));\n                for (const u of invalid) {\n                    fail(`\"${u}\" is an invalid URL; found on line ${chalk.bold.yellow(idx)} of the ${chalk.bold.blue(basename(file))} prompt file`)\n                }\n            }\n            if(s.verbose) {\n                info(`found ${chalk.bold.yellow(validUrls.length)} valid urls on line ${chalk.bold(idx)} of ${chalk.bold.blue(basename(file))}`)\n                if(s.verbose) {\n                    for (const u of validUrls) {\n                        infoIndent(u)\n                    }\n                }\n                for (const u of validUrls) {\n                    const md = await getPage(u, s);\n\n                    content += `\n\n##### Webpage Content of ${u}\n\n\\`\\`\\`md\n${md}\n\\`\\`\\`\n`\n                }\n            }\n\n        } else {\n            content += line + \"\\n\";\n            aiderContent += line + \"\\n\";\n        }\n    }\n\n    return {\n        kind: \"prompt\",\n        promptFile: file,\n        frontmatter,\n        characters,\n        isCached,\n        lines: lines.length,\n        content: content.trimEnd() + \"\\n\",\n        aiderContent,\n        codeRefs,\n        unmatchedCodeRefs,\n        webRefs,\n        invalidWebRefs,\n        failedWebRefs,\n        errors\n    } satisfies Prompt \n}\n\n\n","import { createKindError } from \"@yankeeinlondon/kind-error\";\n\nexport const InputOutput = createKindError(\n    \"InputOutput\"\n);\n\nexport const ClipboardError = createKindError(\"ClipboardError\");\n\nexport const BrowserError = createKindError(\"BrowserError\");\n","import util from \"util\";\nimport chalk from \"chalk\";\n\nchalk.level = 3; // Force full 24-bit color support\n\nexport const CROSS = chalk.bold.red(\"⤫\");\nexport const CHECK = chalk.bold.green(\"✓\");\nexport const INSPECT = chalk.bold(\"👓\");\nexport const INFO = chalk.bold(\"⊙\");\nexport const INFO2 = chalk.bold(\"⊚\");\n\nfunction formatMessage(message: unknown, indentLevel: number = 0): string {\n    let formattedMessage: string;\n\n    // Preserve chalk formatting for strings\n    if (typeof message === \"string\") {\n        formattedMessage = message;\n    } else {\n        // Format objects with colors, depth, and better readability\n        formattedMessage = util.inspect(message, { colors: true, depth: null });\n    }\n\n    // Indent multiline messages correctly\n    const indent = \"  \".repeat(indentLevel);\n    return formattedMessage\n        .split(\"\\n\")\n        .map((line, index) => (index === 0 ? line : indent + line))\n        .join(\"\\n\");\n}\n\nfunction logToStderr(prefix: string, args: unknown[], indentLevel = 0) {\n    if (args.length > 1) {\n        process.stderr.write(`${prefix} ${formatMessage(args[0], indentLevel)}\\n`);\n        for (const arg of args.slice(1)) {\n            process.stderr.write(formatMessage(arg, indentLevel + 1) + \"\\n\");\n        }\n    } else {\n        process.stderr.write(`${prefix} ${formatMessage(args[0], indentLevel)}\\n`);\n    }\n}\n\nexport function success(...args: unknown[]) {\n    logToStderr(CHECK, args);\n}\n\nexport function info(...args: unknown[]) {\n    logToStderr(INFO, args);\n}\n\nexport function infoIndent(...args: unknown[]) {\n    logToStderr(`    ${INFO2}`, args);\n}\n\nexport function confirm(...args: unknown[]) {\n    logToStderr(INSPECT, args);\n}\n\nexport function fail(...args: unknown[]) {\n    logToStderr(CROSS, args);\n}\n\nexport function log(...args: unknown[]) {\n    if (args.length === 0) {\n        process.stderr.write(\"\\n\")\n    } else {\n        logToStderr(\"\", args)\n    }\n}\n\nexport function stdout(...args: unknown[]) {\n    if(args.length > 1) {\n        console.group(args[0]);\n        for (const a of args.slice(1)) {\n            console.log(a);\n        }\n    } else {\n        console.log(args[0])\n    }\n}\n","import { Browser } from \"happy-dom\";\nimport { ensureLeading, Uri } from \"inferred-types\";\nimport { IGNORE_INVALID_CERT } from \"~/constants\";\nimport { BrowserError } from \"~/errors\";\nimport { HttpHeaders } from \"~/types\";\nimport { asString, log, success } from \"~/utils\";\nimport { Switches } from \"..\";\nimport { htmlToMd } from \"./htmlToMd\";\nimport { writeFileSync, writevSync } from \"node:fs\";\nimport { join } from \"pathe\";\nimport { cwd } from \"node:process\";\n\nexport type GetPageOptions = {\n    bearerToken?: string;\n    apiKey?: {key: string; value: string };\n}\n\n\nexport async function getPage(\n    uri: Uri<\"http\"|\"https\">,\n    s: Switches,\n    opt?: GetPageOptions\n) {\n    const headers: HttpHeaders = {\n        Accept: \"*/*\",\n        UserAgent: \"curl/7.64.1\",\n        \"Accept-Encoding\": \"gzip, deflate, br\",\n        \"Connection\": \"keep-alive\",\n        ...(\n            opt?.bearerToken\n                ? { Authorization: ensureLeading(opt.bearerToken, \"Bearer \")}\n                : {}\n        ),\n    }\n\n    const req = await fetch(uri, { method: \"GET\", headers })\n\n    const browser = new Browser();\n    const page = browser.newPage();\n    performance.mark('start');\n    const resp = await page\n        .goto(uri);\n\n    if(!resp) {\n        return BrowserError(`Unable to get a response from \"${uri}\"`);\n    }\n    \n    const code: number = resp.status;\n    const statusText: string = resp?.statusText;\n\n    if(req?.ok) {\n        // const page = await req.text();\n\n        if (s.verbose) {\n            performance.mark('loaded');\n            // const loading = performance.measure(\"loadingTime\", \"start\", \"loaded\")\n            success(`the page \"${uri}\" was loaded successfully; now waiting for scripts to complete`)\n        }\n        \n        await page.waitUntilComplete();\n        performance.mark('end');\n\n        performance.measure('load-page', 'start', 'loaded')\n        performance.measure('load-to-ready', 'loaded', 'end')\n        performance.measure('total', 'start','end');\n\n        const measurements = [\n            \"load-page\", \"load-to-ready\", \"total\"\n        ].map(i => performance.getEntriesByName(i))\n        if (s.verbose) {\n            success(`page has completed loading`)\n        }\n\n        const main = page.mainFrame.content;\n        writeFileSync(join(cwd(), \"/example.github.html\"), main, \"utf-8\")\n\n        \n\n        const md = await htmlToMd(page);\n        if (s.verbose) {\n            success(`page converted to markdown`)\n        }\n        writeFileSync(join(cwd(), \"/md.md\"), md)\n    }\n\n\n    \n    \n\n    if(IGNORE_INVALID_CERT) {\n        // TODO\n    }\n\n    browser.close();\n}\n","import { BrowserPage } from \"happy-dom\";\nimport { unified } from \"unified\";\nimport rehypeParse from 'rehype-parse'\nimport rehypeRemark from 'rehype-remark'\nimport remarkStringify from 'remark-stringify'\nimport { log } from \"~/utils\";\nimport { isString } from \"inferred-types\";\n\n\n/**\n * Receives HTML content and from that determines:\n * \n * 1. the best DOM query to remove unnecessary clutter\n */\nexport async function htmlToMd(page: BrowserPage | string) {\n\n    if(!isString(page)) {\n        const doc = page.mainFrame.document;\n        const body = doc.body.outerHTML;\n        const md = await unified()\n        .use(rehypeParse)\n        .use(rehypeRemark)\n        .use(remarkStringify)\n        .process(body);\n        \n        log(\"markdown conversion\", {\n            messages:md.messages,\n            htmlLength: body.length,\n            raw: doc.body.textContent\n        })\n\n        return String(md);\n    } else {\n        const md = await unified()\n        .use(rehypeParse)\n        .use(rehypeRemark)\n        .use(remarkStringify)\n        .process(page);\n\n\n        return String(md);\n    }\n\n\n\n}\n","import chalk from 'chalk';\nimport { stripAfter } from 'inferred-types';\nimport { basename, dirname, extname } from 'pathe';\nchalk.level = 3;\n\nexport function prettyFile(file: string) {\n    const base = chalk.dim(dirname(file));\n    const fileName = chalk.blue.bold(stripAfter(basename(file), \".\"));\n    const ext = chalk.dim(extname(file));\n    return `${base}/${fileName}${ext}`\n}\n","/**\n * **link**`(text, link)`\n *\n * Prints a link to the terminal using a relatively new\n * [standard](https://gist.github.com/egmontkob/eb114294efbcd5adb1944c9f3cb5feda) for making pretty links.\n *\n * You can use the following protocols for your links:\n * - `http` / `https`\n * - `file` (note format is `file://hostname/path/to/file.txt` and hostname\n * IS required)\n * - `mailto`\n */\nexport function link(text: string, link: string) {\n    return `\\x1B]8;;${link}\\x1B\\\\${text}\\x1B]8;;\\x1B\\\\`;\n}\n\n","import clipboardy from 'clipboardy';\nimport { ClipboardError } from '~/errors';\n\n/**\n * Copies the provided text to the clipboard.\n * @param text - The text to copy.\n */\nexport async function toClipboard(text: string): Promise<true | Error> {\n    try {\n        await clipboardy.write(text);\n        return true;\n    } catch (error) {\n        return ClipboardError(\n            `Problem copying content to the clipboard`, \n            { underlying: error as string | Error }\n        );\n    }\n}\n","import { Prompt } from \"~/types\";\n\nexport async function updatePromptFile(_p: Prompt) {\n    // TODO\n}\n\n","\nimport chalk from \"chalk\";\nimport { INFO, INFO2, link, log } from \"./utils\";\n\nexport function help() {\n    log();\n    log(chalk.bold.blue(\"prompt \") + chalk.bgWhiteBright.blackBright(\" CLI \"));\n    log(chalk.dim.italic(`a CLI for building powerful AI prompts.`))\n    log();\n\n    log(`- ${chalk.bold(\"Syntax:\")} ${chalk.bold.blue(\"prompt\")} <${chalk.dim.italic(\"prompt file ref\")}> ${chalk.grey.italic(\"<prompt file ref>\")}${chalk.dim(\"[]\")} \"<${chalk.dim.italic(\"freeform text\")}>\"`)\n    log()\n    log(`    ${INFO} ${chalk.italic(\"prompt files\")} should be markdown or text files with either \\n       a .md or .txt file extension.`)\n    log(`    ${INFO} the ${chalk.italic(\"directories\")} where these files should reside are:`)\n    log(`        ${INFO2} by default it will look in \"${chalk.blueBright(`\\${${chalk.yellow(\"ProjRoot\")}}/prompts`)}\" directory ${chalk.italic(\"(and sub-directories)\")}`)\n    log(`        ${INFO2} if you want to ${chalk.italic(\"add\")} more directories to the possible locations just set the ${chalk.bold(\"PROMPTS\")}`)\n    log(`          env variable. This variable will be delimited by the ${chalk.bold.blue(\":\")} character as is common`)\n    log(`          in ENV variables.`)\n    log(`        ${INFO2} you can also add a ${chalk.blue.bold(\".prompt.json\")} file in the ProjRoot of a repo and set ${chalk.bold.blue(\"promptDirs\")} to the `)\n    log(`          directory/directories you want to use within this repo.  When this property is set`)\n    log(`          the ${chalk.italic(\"default\")} value of \"${chalk.blueBright(`\\${${chalk.yellow(\"ProjRoot\")}}/prompts`)}\" will be ${chalk.bold(\"overwritten\")} but any additional`)\n    log(`          directories you've specified with the ${chalk.bold(\"PROMPT\")} ENV variable will still be used`)\n    log(`          for fallback.`)\n    log()\n    log(`- ${chalk.bold(\"Prompt Files\")}`)\n    log()\n    log(`    ${INFO} prompt files are text files with super powers`)\n    log(`    ${INFO} we recommend Markdown files but plain text files are ok too`)\n    log(`    ${INFO} any line in a prompt file which starts with ${chalk.bold.green(\"::code\")} is a \"code reference directive\":`)\n    log(`        ${INFO2} an example usage would be: ${chalk.bold.green(\"::code Dictionary.ts, Data.json\")}`)\n    log(`        ${INFO2} using this example, the filenames ${chalk.bold.blue(\"Dictionary.ts\")} and ${chalk.bold.blue(\"Data.json\")} will be searched`)\n    log(`          for in the ${chalk.italic(\"code path\")}; where the \"code path\" is by default the following:`)\n    log(`               - \"${chalk.blueBright(`\\${${chalk.yellow(\"ProjRoot\")}}/src`)}\"`)\n    log(`               - \"${chalk.blueBright(`\\${${chalk.yellow(\"ProjRoot\")}}/test`)}\"`)\n    log(`               - \"${chalk.blueBright(`\\${${chalk.yellow(\"ProjRoot\")}}/tests`)}\"`)\n    log(`        ${INFO2} by setting the ${chalk.bold.blue(\"codePath\")} variable in a repo's ${chalk.blue.bold(\".prompt.json\")} file you can`);\n    log(`          override this to whatever you want`)\n    log(`     ${INFO} in addition to ${chalk.italic(\"code\")} references there are also ${chalk.bold(\"web\")} and ${chalk.bold(\"doc\")} references:`)\n    log(`        ${INFO2} a ${chalk.bold(\"web\")} reference brings in a summary for a webpage`);\n    log(`        ${INFO2} a ${chalk.bold(\"doc\")} reference allows the injection of ${chalk.italic(\"sub-contextual\")} information and`)\n    log(`          allows for more granular reuse patterns`)\n    log(`    ${INFO} see the ${link(chalk.bold.blue.underline(\"docs\"), `https://github.com/yankeeinlondon/promptly/README.md`)} for more info on these reference types`)\n\n    log();\n    log(`- ${chalk.bold(\"CLI Flags\")}`)\n    log();\n    log(`    ${INFO} ${chalk.bgGrey.whiteBright(` --output ${chalk.dim(\"<filename>\")} `)}, ${chalk.bgGrey.whiteBright(` -o ${chalk.dim(\"<filename>\")} `)}`)\n    log(`        ${INFO2} every successful run of the CLI puts the ${chalk.italic(\"interpolated\")} prompt on the clipboard`)\n    log(`        ${INFO2} by having it on the clipboard it becomes easy to copy it into open chat`)\n    log(`          windows ${chalk.italic.dim(\"(if that's how you role)\")}`)\n    log(`        ${INFO2} but using this flag allows you to export it to a local file if you prefer`)\n\n    log(`    ${INFO} ${chalk.bgGrey.whiteBright(` --replace `)}`)\n    log(`        ${INFO2} similar to the --output flag but instead of providing a file name, it will ${chalk.italic(\"replace\")}`)\n    log(`          the input prompt templates with ${chalk.italic(\"interpolated\")} versions of themselves`)\n\n    log(`    ${INFO} ${chalk.bgGrey.whiteBright(\" --aider \")}`)\n    log(`        ${INFO2} this CLI can be used as a ${chalk.italic(\"frontend\")} for ${link(chalk.bold.blue(\"Aider\"), \"https://aider.org\")}`)\n    log(`        ${INFO2} when this flag is used the ${chalk.bold(\"web\")} and ${chalk.bold(\"file\")} interpolations normally done will instead`)\n    log(`          be converted into ${chalk.blue.bold(\"/add\")} and ${chalk.blue.bold(\"/web\")} commands and the Prompt along with these commands`)\n    log(`          will be streamed into aider and processed there`)\n\n    log(`    ${INFO} ${chalk.bgGrey.whiteBright(\" --dry-run \")}`)\n    log(`        ${INFO2} prevents the references found in Prompt files from being interpolated into the prompts`)\n    log(`        ${INFO2} instead it just reports on the structure of the prompt `)\n    log(`        ${INFO2} useful way to quickly check that your CLI command is structurally sound`)\n}\n","import chalk from \"chalk\";\nimport { PROMPTS_GLOB, ROOT } from \"./constants\";\nimport { codeDirectories, promptDirectories } from \"./report\";\n\nimport FastGlob from \"fast-glob\";\nimport { dirname } from \"pathe\";\nimport { INFO, log, prettyFile } from \"./utils\";\n\nexport async function envReport() {\n    log(`ENV for ${chalk.bold.blue(\"prompt\")} CLI`);\n    log();\n    log(`The CLI is being run in the ${chalk.bold.blue(dirname(process.env.PWD as string))} directory`)\n    log(`    ${INFO} the detected repo root is ${ROOT}`)\n    log();\n    log()\n    promptDirectories();\n    log(`Based on these directories the glob pattern for prompts is:`)\n    PROMPTS_GLOB.map(i => {\n        log(`    ${INFO} \"${i}\"`)\n    })\n    log();\n    log(`Which results in the discovery of the following ${chalk.bold(\"prompt\")} files:`)\n    const files = await FastGlob(PROMPTS_GLOB);\n    for (const file of files) {\n        log(`    ${INFO} ${prettyFile(file)}`)\n    }\n    log();\n    codeDirectories();\n}\n","import { CODE_PATHS, PROMPTS_DIR } from \"./constants\";\nimport chalk from \"chalk\";\nimport { dirname } from \"path\";\nimport { relative } from \"pathe\";\nimport { filename } from \"pathe/utils\";\nimport { INFO, log } from \"./utils\";\n\n/**\n * Prints the _directories_ we are looking in for the inline file \n * references.\n */\nexport function codeDirectories() {\n\n    const dirs = CODE_PATHS.map(\n        i => {\n            const rel = relative(process.cwd(), i);\n            return `- ${chalk.blue(dirname(rel))}/${chalk.bold.blue(filename(rel))}`\n        }\n    )\n\n    console.log(`The prompt's ${chalk.italic(\"inline code references\")} are looked for this repo's directories:`)\n    console.log(\"\")\n    console.log(dirs.join(\"\\n\"))\n    console.log();\n}\n\nexport function promptDirectories() {\n    log(`The CLI looks for ${chalk.bold(\"prompts\")} in the following directories:`)\n    log()\n    log(PROMPTS_DIR.map(i => `  ${INFO} ${i}`).join(\"\\n\"))\n    log();\n}\n","import { createKindError, isError } from \"@yankeeinlondon/kind-error\";\nimport { AlphaChar, DefineObject, ensureLeading, ExpandDictionary, FromDefn, isArray, isString, stripLeading, valuesOf } from \"inferred-types\";\n\nexport type CliSwitch = \"string\" \n| \"number\" \n| \"boolean\"\n| [short: string, \"string\" | \"number\" | \"boolean\"];\n\n\ntype NoShort<T extends Record<string,CliSwitch>> = {\n    [K in keyof T]: T[K] extends [string, infer Type extends CliSwitch]\n    ? Type\n    : T[K];\n}\n\ntype Switch = `-${string}`;\ntype SwitchKey = `${AlphaChar}${string}`\n\nconst NoSwitchDefn = createKindError(\n    \"NoSwitchDefn\"\n)\n\n\n\n/**\n * Allows the runtime to specify the switch configuration types\n * which are expected.\n */\nexport function configSwitches<\n    T extends Record<K,CliSwitch>,\n    K extends SwitchKey\n>(\n    input: string[],\n    defn: T\n) {\n    // strip off CLI name and runner\n    input = input.slice(2);\n    const args: string[] = [];\n    const switches = {\n        unknown: [] as string[]\n    } as Record<\"unknown\", any>\n    \n    const shortLookup: Record<Switch, string> = Object.entries(defn)  \n        .reduce(\n            (acc, [key,val]) => {\n                if (isArray(val) && isString(val[0])) {\n                    return { ...acc, [ensureLeading(val[0], \"-\")]: ensureLeading(key, \"--\")}\n                }\n                else return acc;\n            },\n            {}\n        );\n\n    const switchValues = [\n        // long swiches\n        ...Object.keys(defn).map(i => ensureLeading(i, \"--\")),\n        // short swiches\n        ...Object.values(defn)\n            .filter(\n                i => isArray(i)\n            )   \n            .map(\n                i => ensureLeading((i as [string, string])[0], \"-\")\n            )\n    ];\n\n\n    function isSwitch(val: string): val is Switch {\n        return val.startsWith(\"-\")\n    }\n    function isKnownSwitch(val: string): val is Switch {\n        return switchValues.some(i => val.startsWith(i));\n    }\n    function isShortSwitch(val: string) {\n        return val.startsWith(\"-\") && !val.startsWith(\"--\")\n    }\n\n    for(let idx=0; idx<input.length; idx++) {\n        const val = input[idx];\n        if(isSwitch(val)) {\n            if(isKnownSwitch(val)) {\n                const long = isShortSwitch(val) && val in shortLookup\n                    ? shortLookup[val]\n                    : val;\n\n                if(!(stripLeading(long,\"--\") in defn)) {\n                    throw NoSwitchDefn(`the switch \"${long}\" was unable to be found in the switch definition provided but somehow it was classified as a known switch. This should not happen.`)\n                }\n                const key = stripLeading(long,\"--\") as keyof typeof defn & keyof typeof switches;\n                const sw = defn[key] as CliSwitch;\n                const typeOf = isArray(sw) ? sw[1] : sw;\n\n                switch(typeOf) {\n                    case \"boolean\":\n                        switches[key] = true;\n                        break;\n                    case \"number\":\n                        idx++;\n                        const numToken = input[idx];\n                        switches[key] = Number(numToken);\n                        break;\n                    case \"string\": \n                        idx++;\n                        const strToken = input[idx];\n                        switches[key] = strToken;\n                        break;\n                }\n\n            } else {\n                switches[\"unknown\"].push(val)\n            }\n\n        } else {\n            args.push(val);\n        }\n    } // end FOR loop\n\n\n    return {\n        defn,\n        args,\n        switches: switches as ExpandDictionary<\n            FromDefn<NoShort<T>> & Record<\"unknown\", string[]>\n        >,\n    }\n\n}\n"],"mappings":"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","names":["exit","FastGlob","cwd","join","readFileSync","createKindError","chalk","isObject","filename","stripLeading","createKindError","chalk","basename","join","args","args","isString","main","createKindError","stripLeading","chalk","join","basename","chalk","basename","extname","link","cwd","join","createKindError","readFileSync","chalk","ask","chalk","cwd","exit","writeFileSync","args","FastGlob","chalk","exit","cwd","ask","chalk","chalk","chalk","chalk","dirname","relative","relative","chalk","dirname","FastGlob","dirname","chalk","dirname","FastGlob","createKindError","ensureLeading","isArray","isString","stripLeading","args","switches","exit"]}